name: Sync Wishlist Cache

on:
  issues:
    types:
      - opened
      - edited
      - deleted
      - reopened
  issue_comment:
    types:
      - created
      - edited
      - deleted
  workflow_dispatch:

concurrency:
  group: sync-cache
  cancel-in-progress: false

jobs:
  sync-cache:
    runs-on: ubuntu-latest
    
    permissions:
      contents: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      
      - name: Install dependencies
        run: npm install @octokit/rest
      
      - name: Fetch wishlist data from GitHub API
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          node scripts/generate-cache.mjs
      
      - name: Check if cache was generated and changed
        id: cache_check
        run: |
          if [ -f all-wishlists.json ]; then
            echo "Cache file exists"
            if git diff --quiet all-wishlists.json 2>/dev/null; then
              echo "changed=false" >> $GITHUB_OUTPUT
              echo "‚ÑπÔ∏è Cache file exists but no git changes detected"
            else
              echo "changed=true" >> $GITHUB_OUTPUT
              echo "‚úì Cache has git changes"
            fi
          else
            echo "‚ö†Ô∏è Cache file not found!"
            echo "changed=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Configure git
        run: |
          git config user.name "oss-wishlist-bot"
          git config user.email "bot@oss-wishlist.dev"
      
      - name: Pull latest before commit
        run: |
          git fetch origin main
          git rebase origin/main || git rebase --abort
      
      - name: Commit and push cache update
        if: steps.cache_check.outputs.changed == 'true'
        run: |
          git add all-wishlists.json
          
          if [ "${{ github.event_name }}" == "issues" ]; then
            ISSUE_NUM="${{ github.event.issue.number }}"
            ISSUE_ACTION="${{ github.event.action }}"
            COMMIT_MSG="chore: update wishlist cache from issue #${ISSUE_NUM} (${ISSUE_ACTION})"
          elif [ "${{ github.event_name }}" == "issue_comment" ]; then
            ISSUE_NUM="${{ github.event.issue.number }}"
            COMMENT_ACTION="${{ github.event.action }}"
            COMMIT_MSG="chore: update wishlist cache from comment on issue #${ISSUE_NUM} (${COMMENT_ACTION})"
          else
            COMMIT_MSG="chore: update wishlist cache (manual trigger)"
          fi
          
          git commit -m "${COMMIT_MSG}"
          git push origin main
      
      - name: Force add and commit if no changes detected
        if: steps.cache_check.outputs.changed == 'false' && hashFiles('all-wishlists.json') != ''
        run: |
          git add -f all-wishlists.json
          git commit -m "chore: update wishlist cache (force commit)" || echo "Nothing to commit"
          git push origin main || echo "Nothing to push"
```

---

## File 2: `scripts/generate-cache.mjs` (SIMPLIFIED - Issue Body is Source of Truth)

```javascript
#!/usr/bin/env node

import { Octokit } from "@octokit/rest";
import fs from "fs";

const octokit = new Octokit({
  auth: process.env.GITHUB_TOKEN,
});

function extractSection(body, sectionHeader) {
  const regex = new RegExp(
    `### ${sectionHeader}\n([\\s\\S]*?)(?=###|$)`,
    "i"
  );
  const match = body.match(regex);
  if (!match) return "";
  return match[1].trim();
}

function parseCheckboxes(content) {
  const lines = content.split("\n");
  return lines
    .filter((line) => line.includes("[x]"))
    .map((line) => {
      const match = line.match(/\[x\]\s*(.+?)(?:\s*-|$)/);
      return match ? match[1].trim() : "";
    })
    .filter((item) => item.length > 0);
}

function parseCommaSeparated(content) {
  return content
    .split(",")
    .map((item) => item.trim())
    .filter((item) => item.length > 0);
}

function parseWishlistIssue(issue, labels) {
  const isApproved = labels.some((label) => label.name === "approved-wishlist");
  const body = issue.body || "";

  // Extract all sections from the issue body (which is the source of truth)
  const projectName = extractSection(body, "Project Name").trim();
  const maintainerUsername = extractSection(body, "Maintainer GitHub Username")
    .trim()
    .replace(/^@/, ""); // Remove @ if present
  const repositoryUrl = extractSection(body, "Project Repository").trim();
  const ecosystemsText = extractSection(body, "Package Ecosystems");
  const technologies = parseCommaSeparated(ecosystemsText);
  const servicesText = extractSection(body, "Services Requested");
  const wishes = parseCheckboxes(servicesText);
  const resourcesText = extractSection(body, "Resources Requested");
  const resources = parseCheckboxes(resourcesText);
  const urgencyText = extractSection(body, "Urgency Level");
  const projectSize = extractSection(body, "Project Size").trim();
  const additionalNotes = extractSection(body, "Additional Notes").trim();
  const additionalContext = extractSection(body, "Additional Context").trim();

  // Extract urgency level (convert from format with description to simple value)
  const urgencyMatch = urgencyText.match(/^\s*(.+?)(?:\s*-|$)/m);
  const urgency = urgencyMatch ? urgencyMatch[1].trim() : "";

  return {
    id: issue.number,
    projectName: projectName || `Wishlist: ${issue.title}`,
    repositoryUrl,
    maintainerUsername,
    maintainerAvatarUrl: maintainerUsername
      ? `https://github.com/${maintainerUsername}.png`
      : "",
    approved: isApproved,
    wishes,
    technologies,
    resources,
    urgency,
    projectSize,
    additionalNotes,
    additionalContext,
    status: isApproved ? "approved" : "pending",
    createdAt: issue.created_at,
    updatedAt: issue.updated_at,
  };
}

async function generateCache() {
  try {
    console.log("üìã Fetching wishlists from GitHub...");

    const issues = await octokit.paginate("GET /repos/{owner}/{repo}/issues", {
      owner: "oss-wishlist",
      repo: "wishlists",
      state: "open",
      per_page: 100,
    });

    console.log(`‚úì Found ${issues.length} open issues`);

    const wishlists = issues
      .filter((issue) => !issue.pull_request)
      .map((issue) => parseWishlistIssue(issue, issue.labels));

    console.log(`‚úì Parsed ${wishlists.length} wishlists`);

    // Generate metadata
    const approvedCount = wishlists.filter((w) => w.approved).length;
    const allTechnologies = [
      ...new Set(wishlists.flatMap((w) => w.technologies)),
    ].sort();
    const allServices = [...new Set(wishlists.flatMap((w) => w.wishes))].sort();

    const cacheData = {
      version: "1.0.0",
      generatedAt: new Date().toISOString(),
      totalWishlists: wishlists.length,
      approvedCount,
      pendingCount: wishlists.length - approvedCount,
      ecosystemStats: allTechnologies.reduce((acc, tech) => {
        acc[tech] = wishlists.filter((w) => w.technologies.includes(tech))
          .length;
        return acc;
      }, {}),
      serviceStats: allServices.reduce((acc, service) => {
        acc[service] = wishlists.filter((w) => w.wishes.includes(service))
          .length;
        return acc;
      }, {}),
      wishlists,
    };

    fs.writeFileSync("all-wishlists.json", JSON.stringify(cacheData, null, 2));

    console.log("‚úì Cache generated successfully");
    console.log(
      `  - ${approvedCount} approved wishlists`
    );
    console.log(
      `  - ${wishlists.length - approvedCount} pending wishlists`
    );
    console.log(
      `  - ${allTechnologies.length} unique technologies`
    );
    console.log(`  - ${allServices.length} unique services`);
  } catch (error) {
    console.error("‚ùå Error generating cache:", error);
    process.exit(1);
  }
}

generateCache();
